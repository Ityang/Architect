## 六大设计原则

1. 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。

2. 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。
3. 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。
4. 依赖倒置原则：把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。面向接口编程，上层模块不应该依赖下层模块，两者应该依赖抽象；抽象不应依赖于细节，细节应该依赖于抽象。
5. 迪米特法则：又名“最少知道原则”，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。一个对象对其他的对象有最少的了解，尽量降低类与类之间的耦合
6. 接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性会提高，开发难度变大。

## 设计模式分类

设计模式可以分为三大类，创建型、结构型和行为型。

### 创建型

#### 1. 工厂设计模式

定义：由子类决定实例化哪一个类

核心：创建一个具体类型的对象

#### 2. 抽象工厂设计模式



#### 3. 单例模式

定义：一个类只能由一个实例

类型：懒汉式、饿汉式、静态内部、枚举单例、DCL双重校验

优点：性能好、内存少、优化资源访问

缺点：容易造成内存泄露，扩展困难

#### 4.建造者模式

定义：一步一步创建一个复杂对象的创建型模式

场景：参数多、可能需要有执行顺序、有默认值

优点：封装良好，隐藏实现的细节，容易扩展

#### 5.原型模式

定义：克隆对象

场景：1.创建实例消耗的资源较多 2.创建过程繁琐或者需要权限

相关知识：深拷贝、浅拷贝

优点：在内存中二进制拷贝

缺点：内存中执行，构造函数不执行

### 结构型

#### 6. 适配器模式



#### 7.装饰器模式

定义：动态的给对象添加额外的职责

场景：透明且动态的给类添加功能

#### 8.代理模式

定义：为其他对象提供一种代理以控制对这个对象的访问

场景：保证客户端的透明性，控制访问

动态代理：从内存中产生 class 对象，通过反射动态代理

静态代理：代理类的 class 字节码，在运行之前就已经生成

#### 9.外观模式

定义：提供一个外观类使得整个系统的接口只有一个统一的高层接口

场景：复杂子系统提供统一接口，构建有层次的子系统

#### 10.桥接模式

定义：将抽象部分与实现部分分离，使他们可以独立变化

场景：存在两个变化的维度的时候使用，比如对第三方 SDK 的统一封装

#### 11.组合模式



#### 12.享元模式



### 行为型

#### 13.观察者模式

定义：一个对象状态发生变化，所有依赖它的对象都会收到通知并自动更新

场景：一对多，订阅关系，可解除

优点：观察者和被观察者之间是抽象耦合，灵活可扩展

缺点：可能存在效率问题，一个观察者卡顿，可能会导致整个过程卡顿

#### 14.策略设计模式

定义：策略模式定义了一系列算法，并将每个算法封存起来，而且使他们可以相互替换

场景：同一问题的不同解决办法

优点：遵守开闭原则，单一职责原则

#### 15.模版方法模式

定义：定义一个操作中的算法框架，而将一些步骤延迟到子类，不改变算法的机构即可重新定义算法中的某些关键步骤

场景：多个子类基本逻辑相同，有共有方法

#### 16.迭代子模式



#### 17.责任链模式

定义：使很多对象都有机会处理请求，从而避免类请求的发送者和接受者的耦合关系

场景：多对象处理统一请求

相关知识：Android中的事件分发、OkHttp 中发送请求和处理请求

#### 18.命令模式



#### 19.备忘录模式



#### 20.状态模式



#### 21.访问者模式



#### 22.中介者模式



#### 23.解释器模式

