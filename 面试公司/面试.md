三棵树，channel 通信原理，内存分配，启动模式，单例，flutter单线程模型，动画分类，线程池，handler，锁，provider getx 状态库的比对，性能优化，flutter 和原生对比，feature 和ioslate，

## Flutter

### 1.三棵树

### 2.Flutter 单线程模型

### 3.Flutter动画分类

### 4.provider、getX状态库对比

### 5.Flutter 与原生对比

### 6.future 和ioslate

### 7.channel 通信原理

## Android

### 1.启动模式

我们每次打开一个新的Activity或者退出当前Activity都会在一个称为任务栈的结构中添加或者减少一个Activity组件，

一个任务栈包含了一个activity的集合。

android通过ActivityRecord、TaskRecord、ActivityStack，ActivityStackSupervisor，ProcessRecord有序地管理每

个activity。

**1. Standard**

默认模式，每次启动Activity都会创建一个新的Activity实例。

**2. SingleTop**

通知消息打开的页面

如果要启动的Activity已经在栈顶，则不会重新创建Activity，只会调用该该Activity的onNewIntent()方法。

如果要启动的Activity不在栈顶，则会重新创建该Activity的实例。

**3. SingleTask**

主界面

如果要启动的Activity已经存在于它想要归属的栈中，那么不会创建该Activity实例，将栈中位于该Activity上的所有的

Activity出栈，同时该Activity的onNewIntent()方法会被调用。

**4. SingleInstance**

呼叫来电界面

要创建在一个新栈，然后创建该Activity实例并压入新栈中，新栈中只会存在这一个Activity实例。

**5. singleInstancePerTask**

`singleInstancePerTask`的作用和`singleTask`几乎一模一样，*不过singleInstancePerTask不需要为启动的Activity设置一个特殊的taskAffinity就可以创建新的task*，换句话讲就是设置`singleInstancePerTask`模式的`activity`可以存在于多个task任务栈中，并且在每个任务栈中是单例的。

多次启动设置singleInstancePerTask模式的Activity并不会多次创建新的任务栈，而是如singleInstance模式一样，把当前Activity所在的任务栈置于前台展示，如果想每次以新的任务栈启动需要设置`FLAG_ACTIVITY_MULTIPLE_TASK`和`FLAG_ACTIVITY_NEW_DOCUMENT`

### 2.单例设计模式

[单例设计模式](https://github.com/Ityang/Architect/blob/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md)

### 3.Handler机制

### 4.线程池

### 5.锁

### 6.内存优化

### 7.性能优化

### 8.Android 动画分类

