### 1.组件化



### 2.线程池策略

#### 2.1`AbortPolicy（默认策略）`

当任务无法被线程池执行时，会抛出一个RejectedExecutionException异常。

AbortPolicy是Java线程池中默认的拒绝策略。当线程池达到其最大容量，并且工作队列也满了，无法再接受新的任务时，使用AbortPolicy策略会直接抛出RejectedExecutionException异常。这个异常表明任务因为线程池的资源不足而被拒绝。

**业务场景**

假设有一个电商平台，需要处理大量的订单处理任务。在高流量的促销活动期间，订单量可能会突然激增，导致线程池中的线程数和队列容量都达到上限。如果继续提交任务，使用AbortPolicy策略，系统会抛出异常，提示开发者或者系统管理员需要关注线程池的资源限制问题。

在这个示例中，我们创建了一个固定大小为5的线程池，并且使用了LinkedBlockingQueue作为工作队列。我们提交了10个任务，每个任务简单地打印一条消息并休眠1秒。

当尝试提交第11个任务时，由于线程池中的线程数和队列都已满，任务无法被执行。此时，线程池使用默认的AbortPolicy策略，抛出RejectedExecutionException异常。这个异常可以通过捕获来处理，例如在示例中，我们通过catch块捕获了这个异常，并打印了一条消息。

这种策略适合于那些不能容忍任务被丢弃或延迟执行的业务场景，因为它会立即通知调用者任务被拒绝，从而可以采取相应的措施，比如增加线程池大小、优化任务执行效率或者通知用户等待。

#### 2.2 `DiscardPolicy`

当任务无法被线程池执行时，任务将被丢弃，不抛出异常，也不执行任务。

DiscardPolicy是Java线程池中的一种拒绝策略，它在任务无法被线程池执行时，会直接丢弃该任务，不执行也不抛出任何异常。

**业务场景**

假设有一个日志收集系统，该系统负责收集来自多个服务的日志信息。由于日志信息量巨大，线程池可能很快就会达到其最大容量，并且工作队列也会被填满。在这种情况下，使用DiscardPolicy策略可以避免系统因为尝试处理大量日志信息而变得不稳定或崩溃。对于日志信息来说，丢弃一些信息可能是可接受的，因为它们可以稍后通过其他方式重新收集或恢复。

在这个示例中，我们创建了一个固定大小为2的线程池，并且设置了工作队列的大小为2。这意味着线程池最多只能同时执行2个任务，并且队列中最多只能有2个等待执行的任务。

我们提交了5个任务，每个任务简单地打印一条消息并休眠1秒。当提交第3个任务时，线程池的线程数和队列都已满，根据DiscardPolicy策略，这个任务将被丢弃，不会有任何异常抛出，也不会有消息打印出来。

这种策略适合于那些对任务执行的及时性要求不高，或者任务可以被安全丢弃的业务场景。例如，在日志收集、数据监控、非关键性消息处理等场景中，使用DiscardPolicy可以避免系统因为处理大量任务而变得不稳定。然而，需要注意的是，使用这种策略可能会导致数据丢失或任务未被执行，因此在决定使用DiscardPolicy之前，需要仔细考虑业务需求和潜在的影响。

### 2.3 `DiscardOldestPolicy`

当任务无法被线程池执行时，线程池会丢弃队列中最旧的任务，然后尝试再次提交当前任务。

DiscardOldestPolicy是Java线程池中的一种拒绝策略，当线程池中的线程数达到其最大容量，并且工作队列也满了，无法再接受新的任务时，使用DiscardOldestPolicy策略会从队列中丢弃最旧的任务（即队列头部的任务），然后尝试再次提交当前任务。

**业务场景**

假设有一个实时数据处理系统，该系统需要处理来自传感器的实时数据流。在这种情况下，系统可能更倾向于处理最新的数据，而不是旧的数据，因为最新的数据对于分析和决策更为重要。使用DiscardOldestPolicy策略，系统可以丢弃旧的数据任务，以确保有足够的资源来处理最新的数据。

在这个示例中，我们创建了一个固定大小为2的线程池，并且设置了工作队列的大小为2。这意味着线程池最多只能同时执行2个任务，并且队列中最多只能有2个等待执行的任务。

我们提交了5个任务，每个任务简单地打印一条消息并休眠1秒。当提交第3个任务时，线程池的线程数和队列都已满。根据DiscardOldestPolicy策略，队列中的第一个任务（即任务0）将被丢弃，然后尝试再次提交当前任务（任务3）。这样，任务1和任务2将被执行，任务3将替换任务0的位置并被执行，而任务4和任务5将依次进入队列并被执行。

这种策略适合于那些对最新数据或任务更为敏感的业务场景，例如实时数据处理、股票交易系统、在线游戏服务器等。在这些场景中，丢弃旧的任务以保证新任务的执行可能是一个合理的选择。然而，需要注意的是，使用这种策略可能会导致数据丢失或旧任务未被执行，因此在决定使用DiscardOldestPolicy之前，需要仔细考虑业务需求和潜在的影响。

#### 2.4 `CallerRunsPolicy`

当任务无法被线程池执行时，会直接在调用者线程中运行这个任务。如果调用者线程正在执行一个任务，则会创建一个新线程来执行被拒绝的任务。

CallerRunsPolicy是Java线程池中的一种拒绝策略，当线程池中的线程数达到其最大容量，并且工作队列也满了，无法再接受新的任务时，使用CallerRunsPolicy策略会将任务交由调用者线程（即提交任务的线程）来执行。如果调用者线程已经在执行一个任务，则会创建一个新线程来执行被拒绝的任务。

**业务场景**

假设有一个在线视频处理服务，用户上传视频后，服务需要对视频进行转码、压缩等处理。在某些情况下，如果视频处理任务过多，线程池可能会达到其最大容量，此时使用CallerRunsPolicy策略可以保证任务不会被丢弃，而是在调用者线程中执行，从而确保所有上传的视频都能得到处理。

在这个示例中，我们创建了一个固定大小为2的线程池，并且使用了CallerRunsPolicy作为拒绝策略。我们提交了4个任务，每个任务简单地打印一条消息并休眠1秒。

当尝试提交第5个任务时，由于线程池中的线程数和队列都已满，任务无法被线程池中的线程执行。此时，根据CallerRunsPolicy策略，任务将由提交任务的线程（即main线程）来执行。因此，你会看到"Task 5 is running in the caller thread."这条消息被打印出来。

这种策略适合于那些可以容忍任务在调用者线程中执行的业务场景，它允许任务继续执行，而不会因为线程池资源不足而被丢弃。但是，需要注意的是，如果调用者线程本身就很忙，或者任务执行时间很长，这可能会导致调用者线程被阻塞，从而影响系统的响应性。

### 3.锁



### 4.Glide缓存



### 5.内存泄露怎么做的？如何检测？以及LeakCanary原理



### 6.如何在原生中集成flutter？以及如何进行通讯



### 7.埋点方案



### 8.flutter怎么做的优化



### 9.flutter状态管理



### 10.final 和const的区别

#### 主要区别

1. ##### **初始化时间**：

   - `final`：变量的值在运行时确定，可以在运行时通过计算或函数调用来赋值。
   - `const`：变量的值在编译时确定，必须是编译时常量。

2. ##### **延迟初始化**：

   - `final`：可以延迟初始化，直到第一次使用。
   - `const`：必须在声明时初始化，且值是编译时常量。

3. ##### **不可变对象**：

   - `final`：可以用于任何变量，确保它在赋值后不可变。
   - `const`：不仅确保变量在赋值后不可变，还可以用于创建不可变对象和常量构造函数。

#### 示例比较

```
dart
复制代码
void main() {
  final currentTime = DateTime.now(); // 运行时确定
  // const currentTimeConst = DateTime.now(); // 错误，const 变量必须是编译时常量

  const maxItems = 100; // 编译时确定
  final maxUsers = 100; // 运行时确定，但只能赋值一次

  print(currentTime); // 输出当前时间
  print(maxItems); // 输出 100
  print(maxUsers); // 输出 100
}
```

总结来说，使用 `final` 关键字可以确保变量只能被赋值一次，适用于需要在运行时确定的值。使用 `const` 关键字可以创建编译时常量和不可变对象，适用于需要在编译时确定的值。