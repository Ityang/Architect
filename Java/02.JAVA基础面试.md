## JAVA基础

#### 1. 接口和抽象类的区别？

1. 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
2. 类可以实现很多个接口，但是只能继承一个抽象类
3. 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
4. 抽象类可以在不提供接口方法实现的情况下实现接口。
5. Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
6. Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
7. 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。

#### 2. Java 中的强、软、弱、虚引用

1. 强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object()” 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象实例。
2. 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象， 在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行 第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。
3. 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱 引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时， 无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。在 JDK 1.2 之 后，提供了 WeakReference 类来实现弱引用。
4. 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象 实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用 来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象 实例被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。

#### 3.hashCode() 与 equals() 生成算法、方法怎么重写

equal和hashCode的关系是这样的：（1）如果两个对象相同（即用equal比较返回true），那么他们的hashcode值一定要相同；（2）如果两个对象的hashcode相同，他们并不一定相同（即用equal比较返回false），因为hashcode的方法是可以重载的，如果不重载，会用Java.long.Object的hashcode方法，只要是不同的对象，hashcode必然不同。

由于为了提高程序的效率才实现了hashcode方法，先进行hashcode的比较，如果不同，就没有必要再进行equal的比较了，这样就大大减少了equals比较的次数，这对需要比较数量很大的运算效率特稿是很多的。

附加：一旦new对象就会在内存中开辟空间，==比较的是对象的地址值，返回的是boolean型，equal方法默认比较的对象的地址值，但是Integer等基本类型包装类以及String类中已经重写了equal（）方法，比较的是对象内存中的内容，返回值是boolean型。
#### 4.Java中Hash码（哈希码）的理解
在Java中，哈希码代表了对象的一种特征，例如我们判断某两个字符串是否==，如果其哈希码相等，则这两个字符串是相等的，其次，哈希码是一种数据结构的算法，常见的哈希码的算法有：

Object类的HashCode，返回对象的内存地址经过处理后的结构，由于每个对象的内存地址都不一样，所以哈希码也不一样。

String类的HashCode，根据String类包含的字符串的内容，根据一种特殊的算法返回哈希码，只要字符串的内容相同，返回的哈希码也相同。

Integer类：返回的哈希码就是integer对象里所包含的那个整数的数值。例如

Integer i1=new Integer(100) i1.hashCode的值就是100，由此可见两个一样大小的Integer对象返回的哈希码也一样。
